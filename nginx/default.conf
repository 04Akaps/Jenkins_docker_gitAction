user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}
http {
  include       /etc/nginx/mime.types;
  default_type  application/octet-stream;

  server {
    listen 3000 ssl;
    listen [::]:3000 default_server;
    server_name _;

    ssl on;

    #PLAY - WEB 3003
    location / {
        proxy_pass http://host.docker.internal:3003;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    location /assets {
        proxy_pass http://host.docker.internal/assets;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    #PLAY - PORT 3001
    location /play/api {
        proxy_pass http://host.docker.internal:3001/play/api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    location /play {
        proxy_pass http://host.docker.internal:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    #EDIT - PORT 3002
    location /edit/api {
        proxy_pass http://host.docker.internal:3002/api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
    location /edit {
        proxy_pass http://host.docker.internal:3002;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
  }
}

http {
    upstream golangserver { 
        hash $remote_addr consistent;

        server 127.0.0.1:8080;
        keepalive 16;
    }

    server {
        listen 80;
        root /Users/yuhojin/Desktop/go_gin_study;
        server_name goginsstudy.com;

        keepalive_timeout 10;
        # 커넥션을 유지하는 시간이다.
        # 길게잡으면 클라이언트는 빠르니깐 좋은데,,, 서버는 요청도 없지만 계속 커넥션을 유지하기 떄문에 손해를 본다.
        # 보통 페이지 로딩 시간보다 조금 길게 잡으면 되니 10초정도??

        location / {
            # server에 들어오는 accessLog
            # local에서 테스트 하면 당연히 127.0.0.1이 찍힌다.
            # 왜냐하면 서버 입장에서는 Client가 접속을 하는 것이 아니라 nginx가 요청을 보내는 것이기 떄문에

            # server에 client의 정보를 넘겨주고자 할 떄 다음과 같은 header를 추가해 주면 된다.
            # 이후 server에서 설정을 해주어야 함.

            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Port $server_port;

            proxy_pass http://golangserver/;

            # 성능을 위한 setting
            # default가 1.0으로 동작

            proxy_http_version 1.1;

            # 1.0은 접속 마다 새로운 connection이 만들어 진다.
            # 또한 접속이 완료되면 바로 접속을 끊게 되어 있다.

            # 1.1은 한번 연결하면 계속해서 연결이 되어 있다.
            proxy_set_header Connection "";
        }

        access_log  /Users/yuhojin/Desktop/go_gin_study/ngnixLogs/host.access.log;
        error_log   /Users/yuhojin/Desktop/go_gin_study/ngnixLogs/error.log;
    }
}

events{}